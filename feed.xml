<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://kaiyanfan.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kaiyanfan.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-01-28T00:22:03+00:00</updated><id>https://kaiyanfan.github.io/feed.xml</id><title type="html">blank</title><subtitle></subtitle><entry><title type="html">GFW Technical Review 06 – HTTPS and Domain Fronting</title><link href="https://kaiyanfan.github.io/blog/2026/gfw06/" rel="alternate" type="text/html" title="GFW Technical Review 06 – HTTPS and Domain Fronting"/><published>2026-01-27T00:00:00+00:00</published><updated>2026-01-27T00:00:00+00:00</updated><id>https://kaiyanfan.github.io/blog/2026/gfw06</id><content type="html" xml:base="https://kaiyanfan.github.io/blog/2026/gfw06/"><![CDATA[<figure style="text-align:center;"> <img src="/assets/img/posts/gfw06/cover.png" width="70%"/> </figure> <p>GFW originated in the late 1990s to early 2000s – the very early days of the Internet. Its original DPI strategies, like keyword and URL matching against plaintext HTTP, have largely lost their effectiveness on the modern Internet. Today, the vast majority of web traffic runs over HTTPS. This is not good news for GFW, but it has found ways to adapt.</p> <hr/> <h4 id="tls">TLS</h4> <p>To understand how GFW handles HTTPS traffic, we first need to understand TLS – the cryptographic protocol underlying HTTPS.</p> <p>When a client connects to an HTTPS server, the two parties perform a TLS handshake immediately after the TCP three-way handshake to establish a secure channel. This handshake accomplishes several things: the server proves its identity through a certificate, the parties agree on cryptographic parameters by exchanging supported cipher suites, and they derive shared session keys for encrypting subsequent communication through a key exchange. Once the handshake completes, all application data is encrypted. An eavesdropper sees only opaque ciphertext and can learn nothing about the content being transferred – which pages are visited, what data is submitted, or what responses are returned.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw06/tls.png" width="70%"/> <figcaption>TLS 1.2 Handshake</figcaption> </figure> <p>However, TLS was not designed with censorship resistance in mind. The handshake itself, particularly in TLS 1.2 and earlier, exposes metadata that proves invaluable to censors. The most significant piece of exposed information is the Server Name Indication, or SNI.</p> <h4 id="server-name-indication-sni">Server Name Indication (SNI)</h4> <p>SNI is a TLS extension that allows a client to indicate which hostname it is attempting to connect to during the handshake. It was introduced to solve a practical problem: a single IP address often hosts multiple HTTPS websites, and the server needs to know which certificate to present before the encrypted channel is established. Although technically optional in the protocol specification, SNI is practically mandatory due to the prevalence of shared hosting, and is used by virtually all clients.</p> <p>The SNI field is sent in the ClientHello message – the very first message from client to server – and it is sent in plaintext. This creates a fundamental information leak: even though the content of HTTPS communication is encrypted, the destination hostname is visible to any network observer.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw06/pcap.png" width="85%"/> <figcaption>Example Client Hello packet. Server domain name is in plaintext</figcaption> </figure> <p>For GFW, SNI is a gift. It provides a reliable, standardized field that reveals exactly which website a user is attempting to visit. GFW can simply inspect the SNI field of every TLS ClientHello and match it against a blocklist of forbidden domains. When a match is found, GFW injects TCP RST packets to terminate the connection, just as it does for other blocked content.</p> <h4 id="encrypted-client-hello-ech">Encrypted Client Hello (ECH)</h4> <p>The plaintext SNI troubles the entire Internet security community. It represents the most substantial privacy leak remaining in the TLS/HTTPS infrastructure. <strong>Encrypted Server Name Indication (ESNI)</strong> was introduced to address this issue, and its successor, <strong>Encrypted Client Hello (ECH)</strong>, has since been standardized as a TLS 1.3 extension.</p> <p>ECH works by splitting the ClientHello into two parts: an outer portion with the standard plaintext ClientHello format, and an inner portion containing encrypted extensions – including the real SNI and other sensitive fields like ALPN. For compatibility reasons, the outer extensions still contain a plaintext SNI, but this is a decoy (often pointing to a generic CDN hostname). Only the encrypted inner SNI reveals the actual destination.</p> <p>Encrypting the inner ClientHello presents a bootstrapping problem: at this point, no TLS connection has been established, so there is no secure channel available. ECH solves this by working in conjunction with DNS – typically DNS-over-HTTPS to prevent DNS-level leakage. Along with the standard IP address, the DNS response includes the server’s ECH configuration, which contains a public key. The client uses this public key to encrypt the inner ClientHello. The server decrypts it and proceeds with the real handshake, while GFW sees nothing useful.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw06/ech.png" width="70%"/> <figcaption>TLS 1.3 Handshake with ECH</figcaption> </figure> <p>ECH poses a major challenge for GFW. It eliminates the only field that GFW can reliably use to identify the destination. Fortunately for GFW, ECH deployment remains limited. While most major browsers already support ECH, server-side adoption will take years to become widespread. This allows GFW to block all ECH connections without causing significant collateral damage for the time being.</p> <p>Researchers have observed that GFW inspects the TLS extension identifiers in ClientHello messages and drops packets (rather than injecting TCP RST) when it detects ESNI or ECH. This is followed by residual censorship on that connection for two to three minutes. However, as ECH adoption grows over the coming years, the collateral damage from blanket blocking will become substantial, and GFW may be forced to abandon this approach.</p> <hr/> <h4 id="domain-fronting">Domain Fronting</h4> <p>Domain fronting is a circumvention technique designed to evade GFW’s SNI-based censorship. It was widely used between 2014 and 2018 in popular circumvention tools like <em>Lantern</em>, exploiting a non-standard behavior that major cloud providers unintentionally supported.</p> <p>In an HTTPS connection, the destination domain name appears in three places: the DNS request, the TLS ClientHello (SNI), and the HTTP Host header inside the encrypted request. The first two are visible to GFW; the third is encrypted.</p> <p>Ordinarily, the same domain name is used in all three places. The key insight of domain fronting is to use different domain names. In the DNS query and TLS SNI – both visible to the censor – the client specifies a benign domain that happens to share infrastructure with the blocked domain. Inside the encrypted HTTP request, the Host header points to the actual blocked destination.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw06/df.png" width="70%"/> <figcaption>Domain Fronting</figcaption> </figure> <h4 id="cdn-infrastructure">CDN Infrastructure</h4> <p>Domain fronting works exceptionally well on the modern Internet, where CDNs are often the first point of entry for web requests. CDN providers such as Google Cloud and Cloudflare act on behalf of origin servers, processing user requests directly. If a request hits a CDN cache, the cached content is returned immediately. Otherwise, the CDN forwards the request to the origin server on the user’s behalf.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw06/cdn.png" width="65%"/> <figcaption>User requests are often handled by CDN frontend servers first</figcaption> </figure> <p>CDN frontend servers typically host a wide range of websites, particularly popular ones. Crucially, they use the HTTP Host header to determine which website a request is intended for. This means that if the TLS SNI and HTTP Host header specify different domains, the CDN will happily accept the TLS connection as long as it hosts the domain in the SNI, but then route the traffic according to the Host header.</p> <p>With domain fronting, GFW loses the ability to block by SNI alone. Its only options are to block the CDN server by IP entirely – causing massive collateral damage – or to let the traffic through. In 2018, Russian authorities attempted to block Telegram, which used domain fronting, by banning 1.8 million IP addresses belonging to major cloud providers. This knocked countless legitimate websites offline. Eventually, the Russian authorities were forced to reverse course and lift the bans.</p> <p>A variation of domain fronting is domain hiding, where the TLS ClientHello simply omits the SNI extension entirely. In this case, GFW has no domain name to match against. SNI-less connections constitute a significant portion of Internet traffic, so blocking them indiscriminately would also incur substantial collateral damage.</p> <h4 id="the-decline-of-domain-fronting">The Decline of Domain Fronting</h4> <p>Domain fronting was a short-lived technique. Though powerful, it relied on unintended behavior that was never part of any Internet standard. Starting around 2018, major cloud and CDN providers began disabling domain fronting.</p> <p>Several factors drove this decision. There were terms-of-service concerns, as domain fronting effectively allows traffic to impersonate one service while actually destined for another. There were also security concerns: attackers could use domain fronting to disguise malicious traffic as legitimate connections to trusted services. And of course, there was speculation that government pressure played a role as well.</p> <hr/> <h4 id="closing-thoughts">Closing Thoughts</h4> <p>As the Internet has shifted toward encryption and HTTPS, GFW faces significant challenges. Classic DPI methodologies have become increasingly ineffective. For now, the presence of plaintext SNI and the decline of domain fronting mean that GFW can still effectively censor HTTPS traffic. But the long-term trend toward ECH may fundamentally alter this dynamic. The rise of HTTPS has also created new opportunities for circumvention technologies. Rather than relying on “looks like nothing” protocols like Shadowsocks, newer protocols have emerged that disguise themselves as legitimate HTTPS traffic, making fingerprinting even more difficult for GFW. We will explore how this cat-and-mouse game continues to evolve in future posts.</p> <hr/> <h4 id="references">References</h4> <ul> <li>Cloudflare. What is a TLS handshake. <a href="https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/">https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/</a></li> <li>Cloudflare. Encrypted Client Hello - the last puzzle piece to privacy. <a href="https://blog.cloudflare.com/announcing-encrypted-client-hello/">https://blog.cloudflare.com/announcing-encrypted-client-hello/</a></li> <li>GFW Report. Exposing and Circumventing China’s Censorship of ESNI. <a href="https://gfw.report/blog/gfw_esni_blocking/en/">https://gfw.report/blog/gfw_esni_blocking/en/</a></li> <li>David Fifield, Chang Lan, Rod Hynes, Percy Wegmann, and Vern Paxson. Blocking-resistant communication through domain fronting. In Proceedings on Privacy Enhancing Technologies 2015. <a href="https://petsymposium.org/2015/papers/03_Fifield.pdf">https://petsymposium.org/2015/papers/03_Fifield.pdf</a></li> <li>Russia Bans 1.8 Million Amazon and Google IPs in Attempt to Block Telegram. <a href="https://www.bleepingcomputer.com/news/government/russia-bans-18-million-amazon-and-google-ips-in-attempt-to-block-telegram/">https://www.bleepingcomputer.com/news/government/russia-bans-18-million-amazon-and-google-ips-in-attempt-to-block-telegram/</a></li> </ul>]]></content><author><name></name></author><category term="GFW"/><summary type="html"><![CDATA[The Internet's shift toward HTTPS presents a major challenge to GFW]]></summary></entry><entry><title type="html">GFW Technical Review 05 – Shadowsocks</title><link href="https://kaiyanfan.github.io/blog/2026/gfw05/" rel="alternate" type="text/html" title="GFW Technical Review 05 – Shadowsocks"/><published>2026-01-23T00:00:00+00:00</published><updated>2026-01-23T00:00:00+00:00</updated><id>https://kaiyanfan.github.io/blog/2026/gfw05</id><content type="html" xml:base="https://kaiyanfan.github.io/blog/2026/gfw05/"><![CDATA[<figure style="text-align:center;"> <img src="/assets/img/posts/gfw05/cover.png" width="70%"/> </figure> <p>In 2012, a developer known as “clowwindy” released Shadowsocks – a lightweight proxy protocol designed specifically for circumventing the GFW. It was initially a simple tool, only a few hundred lines of Python. But it was fast, lightweight, and most importantly, more resilient against GFW than typical VPNs. It quickly caught the attention of the community. Over the following years, it would become the most influential circumvention tool of the 2010s and fundamentally shape the cat-and-mouse game between GFW and circumvention developers.</p> <hr/> <h4 id="design-philosophy">Design Philosophy</h4> <p>Shadowsocks emerged from a simple insight: the best way to evade detection is not to look suspicious in the first place. Unlike VPNs, which have well-known protocol signatures that GFW can easily fingerprint, Shadowsocks was designed from the ground up to be indistinguishable from random noise – a “looks like nothing” protocol. It eschewed the complexity of established protocols like OpenVPN or IPsec in favor of minimalism: a thin encrypted tunnel with no discernible handshake pattern, no fixed header structure, and no protocol-level metadata in plaintext that could serve as a fingerprint.</p> <p>Shadowsocks is also fast and lightweight. It is stateless, requiring no handshakes or key exchanges. It operates as a SOCKS5 proxy on the application layer, rather than as a heavyweight network-layer solution like a VPN.</p> <p>This focus on obfuscation and simplicity made Shadowsocks popular very quickly. It was released as open-source software with a clean, readable implementation. Setting up a server required minimal technical expertise. Configuration was straightforward – just a simple JSON file – and the protocol was lightweight enough to run on cheap VPS instances. This democratized circumvention: anyone with a few dollars a month could operate their own private proxy, making large-scale blocking far more difficult than targeting centralized VPN services.</p> <hr/> <h4 id="architecture">Architecture</h4> <p>Shadowsocks has a straightforward architecture consisting of two components: a client-side application (<em>ss-local</em>) and a server-side service (<em>ss-server</em>).</p> <p><em>ss-local</em> runs on the user’s machine as a standard SOCKS5 proxy (see RFC 1928), accepting connections from local applications such as web browsers. It encrypts the data stream and forwards it to the configured <em>ss-server</em>, which runs on a host outside the censored network. <em>ss-server</em> decrypts the payload, reconstructs the original connection parameters, and relays requests to the intended destination. GFW only observes the fully encrypted data stream between the two Shadowsocks components.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw05/arch.png" width="70%"/> </figure> <hr/> <h4 id="the-shadowsocks-protocol">The Shadowsocks Protocol</h4> <p>Shadowsocks is a stateless protocol. There is no concept of a persistent connection, no handshake, and no key exchange phase. Payload transmission begins as soon as a TCP connection is established between <em>ss-local</em> and <em>ss-server</em>. Cryptographic security relies entirely on a pre-shared secret (password) configured statically on both components.</p> <p>A Shadowsocks packet begins with an Initialization Vector (IV) – a random value used as a salt in the encryption process. The IV is between 8 and 16 bytes depending on the cipher scheme, and it is the only field in the packet that is not encrypted.</p> <p>The encrypted portion begins with a 3-tuple identifier for the target destination: a 1-byte ATYP field defining the address type, a variable-length ADDR field (which can be an IPv4 address, IPv6 address, or domain name), and a 2-byte destination port. Note that this header information is only sent in the first packet; <em>ss-server</em> retains these values for subsequent packets in the same connection.</p> <p>The first packet structure looks like:</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw05/stream_pkt.png" width="70%"/> </figure> <table> <thead> <tr> <th style="text-align: left">ATYP</th> <th style="text-align: center">Type</th> <th style="text-align: right">Address Length</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">0x01</td> <td style="text-align: center">IPv4</td> <td style="text-align: right">4 bytes</td> </tr> <tr> <td style="text-align: left">0x03</td> <td style="text-align: center">Domain</td> <td style="text-align: right">1-byte length + domain string</td> </tr> <tr> <td style="text-align: left">0x04</td> <td style="text-align: center">IPv6</td> <td style="text-align: right">16 bytes</td> </tr> </tbody> </table> <hr/> <h4 id="stream-cipher">Stream Cipher</h4> <p>Shadowsocks’ original encryption method uses <strong>stream ciphers</strong>. First, Shadowsocks derives a master key from the pre-shared password using a process similar to OpenSSL’s <code class="language-plaintext highlighter-rouge">EVP_BytesToKey</code>:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>key = MD5(password) ++ MD5(MD5(password) ++ password) ++ ...
</code></pre></div></div> <p>where <code class="language-plaintext highlighter-rouge">++</code> denotes concatenation. This derivation is repeated until enough key bytes are generated for the chosen cipher. Next, the master key and IV are fed into a keystream generator to produce a stream of pseudorandom bytes. Each byte of the keystream is XORed with the corresponding byte of the plaintext to produce ciphertext. Because both ends share the same master key and IV, they generate identical keystreams and can perform the same XOR operation for both encryption and decryption. Since this process is deterministic, using the master key alone would produce identical ciphertext from identical plaintext – hence the IV adds randomness to ensure different encryptions of the same data yield different ciphertext.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw05/stream.png" width="70%"/> </figure> <p>Shadowsocks supports over a dozen stream cipher schemes with varying security and performance characteristics, but they all follow this same fundamental process, just with different keystream generators.</p> <p>A key drawback of stream ciphers is that they provide only confidentiality, not authenticity. For a man-in-the-middle attacker like GFW, stream ciphers guarantee that they cannot decrypt the communication, but they can still flip bits to modify the plaintext without detection.</p> <hr/> <h4 id="aead">AEAD</h4> <p><strong>AEAD (Authenticated Encryption with Associated Data)</strong> adds authenticity on top of confidentiality. This is achieved by appending an authentication tag that allows the cipher to verify payload integrity.</p> <p>An AEAD-mode Shadowsocks packet has a different wire format. It begins with a 32-byte salt (analogous to the IV in stream cipher mode), which appears only in the first packet of a TCP stream. This is followed by an encrypted length field, which is necessary because AEAD encrypts data in discrete chunks, each terminated by an authentication tag – the length field allows the receiver to locate chunk boundaries. A 16-byte length tag protects the integrity of the length field. Then comes the Shadowsocks payload (ATYP, destination address, port, and actual data), followed by a 16-byte payload tag. This structure introduces significant size overhead compared to stream ciphers, especially for small packets.</p> <p>Note that the length and length tag fields are only required in TCP mode. TCP is a stream protocol that may segment and reassemble data across packet boundaries, so explicit length information is needed. In UDP mode, each chunk corresponds to a single UDP datagram, so the length can be derived from the UDP header.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw05/aead_pkt.png" width="70%"/> <figcaption>Shadowsocks TCP packet format in AEAD-mode</figcaption> </figure> <p>The AEAD encryption process works as follows. First, a master key is derived from the password using <code class="language-plaintext highlighter-rouge">EVP_BytesToKey</code>, just as with stream ciphers. Next, a 32-byte session key is derived by combining the master key and salt using <code class="language-plaintext highlighter-rouge">HKDF-SHA1</code>. This session key is used for the entire data stream. AEAD encrypts each plaintext chunk using the session key and a nonce (a counter starting at 0 that ensures unique encryption within the session). Each chunk requires two AEAD operations – one for the length field and one for the payload – so the nonce increments twice per chunk.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw05/aead.png" width="70%"/> <figcaption>Shadowsocks AEAD Encryption</figcaption> </figure> <p>Given the deterministic nature of key and nonce derivation, decryption works similarly in reverse. The authentication tags now allow the receiver to validate data integrity and discard any packets that fail verification.</p> <p>Shadowsocks supports multiple AEAD ciphers, such as <code class="language-plaintext highlighter-rouge">AEAD_CHACHA20_POLY1305</code> and <code class="language-plaintext highlighter-rouge">AEAD_AES_256_GCM</code>. These are different cipher implementations but share the same overall principles outlined above. The cryptographic internals of these ciphers are beyond the scope of this blog.</p> <hr/> <h4 id="the-redirect-attack">The Redirect Attack</h4> <p>For a long time, the lack of authenticity in stream ciphers was not considered a serious concern. After all, Shadowsocks was designed to circumvent GFW, and GFW doesn’t randomly flip bits in packets – it either blocks connections or lets them through. Stream ciphers are also theoretically weaker against certain attacks like replay attacks (which we’ll cover in future posts), but this didn’t seem to matter in practice. Up until 2020, most Shadowsocks deployments still used stream ciphers without AEAD.</p> <p>This changed when a devastating redirect attack was discovered in 2020, allowing an attacker to fully decrypt recorded Shadowsocks traffic without knowing the password.</p> <p>Here’s how the attack works. First, the attacker captures the encrypted traffic of a Shadowsocks connection – certainly feasible for GFW. The attacker then sets up their own <em>ss-local</em> client and replays this captured traffic to the original <em>ss-server</em>. Crucially, the attacker modifies the target address field to point to a server they control. Since stream ciphers do not guarantee data integrity, <em>ss-server</em> happily decrypts the data and relays it to the attacker’s server:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ss-local (attacker-controlled) &lt;--[encrypted]--&gt; ss-server &lt;--[plaintext]--&gt; target (attacker-controlled)
</code></pre></div></div> <p>The challenge is modifying the target address without knowing the password. The attacker cannot encrypt their desired target address into valid ciphertext directly. However, if the attacker can guess the plaintext of certain bytes in the ciphertext, they can alter those bytes to arbitrary values. This follows from the mathematical properties of stream ciphers.</p> <p>Let <em>c</em> be the ciphertext, <em>p</em> be the plaintext, and <em>k</em> be the keystream. Stream cipher encryption is simply (where ⊕ denotes XOR):</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c = p ⊕ k
</code></pre></div></div> <p>Now suppose the attacker wants to change <em>p</em> to <em>p’</em>. They can compute <em>r</em> such that <code class="language-plaintext highlighter-rouge">p' = p ⊕ r</code>. The corresponding valid ciphertext <em>c’</em> would be:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c' = p' ⊕ k = (p ⊕ r) ⊕ k
</code></pre></div></div> <p>The attacker doesn’t know <em>k</em>, so they cannot compute this directly. However, XOR is both associative and commutative:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c' = (p ⊕ r) ⊕ k = (p ⊕ k) ⊕ r = c ⊕ r
</code></pre></div></div> <p>So the attacker can construct valid ciphertext <em>c’</em> by simply XORing the original ciphertext with r – without ever knowing the keystream.</p> <p>To perform this attack, the attacker needs a packet where they can guess the first 7 bytes, allowing them to replace the address header with one pointing to their server. One simple approach exploits the fact that HTTP responses always begin with “HTTP/1.”. The attacker takes a server-to-client packet (which lacks Shadowsocks’ address header), assumes it’s an HTTP response, and performs the bit-flipping attack. They then construct an attack packet using the original IV plus the modified payload and send it to <em>ss-server</em>.</p> <p>The attacker may not immediately find an HTTP response, but they can try different captured packets until they observe a connection to their target server. This establishes a decryption oracle: they can now replay any captured encrypted packets through this channel to obtain the plaintext. Throughout this entire attack, the attacker never learns the password.</p> <hr/> <h4 id="fingerprinting-shadowsocks">Fingerprinting Shadowsocks</h4> <p>As we’ve seen, both stream cipher and AEAD packets are fully encrypted, aside from the initial IV or salt (which are themselves random values). From GFW’s perspective, Shadowsocks traffic appears to be random bytes.</p> <p>This is Shadowsocks’ greatest strength – but also its weakness. True, GFW cannot identify Shadowsocks through plaintext fields or handshake patterns. However, very few protocols on the Internet are fully encrypted from the first byte. Even secure protocols like TLS have handshake and key exchange phases with specific patterns and plaintext fields. Being <em>fully</em> encrypted is itself suspicious.</p> <p>GFW fingerprints Shadowsocks (and other fully encrypted protocols) through a combination of heuristics. Researchers have identified at least five rules:</p> <ol> <li><strong>Entropy test</strong>: GFW measures packet entropy. High-entropy data flows are likely fully encrypted and therefore suspicious. GFW uses <code class="language-plaintext highlighter-rouge">popcount(pkt) / len(pkt)</code> to quantify entropy; values between 3.4 and 4.6 are flagged as suspicious.</li> <li><strong>First-byte test</strong>: Whether the first 6 bytes are printable ASCII characters (<code class="language-plaintext highlighter-rouge">0x20</code>–<code class="language-plaintext highlighter-rouge">0x7E</code>).</li> <li><strong>Printable ratio test</strong>: Whether more than 50% of the packet consists of printable characters.</li> <li><strong>Contiguous printable test</strong>: Whether more than 20 contiguous bytes are printable characters.</li> <li><strong>Protocol exemption</strong>: Whether the connection matches TLS or HTTP fingerprints. Genuine TLS or HTTP connections are exempted.</li> </ol> <p>Rules 1 to 4 all test whether a packet is likely to be fully encrypted. Typically, all five criteria must be met to trigger blocking – but there are likely additional undiscovered rules, and GFW probably evaluates multiple metrics holistically.</p> <p>Another fingerprinting method exploits packet length. Shadowsocks encryption, whether stream cipher or AEAD, does not alter payload length – only the protocol itself adds bytes for the address header and AEAD tags. The length of the first packet’s underlying traffic is often predictable, as most connections begin with TLS ClientHello or HTTP requests, which have characteristic size distributions.</p> <hr/> <h4 id="closing-thoughts">Closing Thoughts</h4> <p>In 2015, clowwindy ceased development of Shadowsocks due to pressure from authorities. The open-source community took over the project but fragmented into multiple implementations: shadowsocks-libev, shadowsocks-rust, shadowsocks-go, and others.</p> <p>Remarkably, after nearly 15 years of GFW evolution, Shadowsocks remains an effective and widely-used circumvention tool – though newer, more resilient protocols have also emerged. Shadowsocks itself has gone through various iterations as GFW introduced new detection capabilities, and the ongoing arms race continues to drive innovation on both sides.</p> <hr/> <h4 id="references">References</h4> <ul> <li>M. Leech, M. Ganis, Y. Lee, R. Kuris, D. Koblas, and L. Jones. SOCKS Protocol Version 5. RFC 1928. 1996. <a href="https://www.rfc-editor.org/rfc/rfc1928">https://www.rfc-editor.org/rfc/rfc1928</a></li> <li>Alice, Bob, Carol, Jan Beznazwy, and Amir Houmansadr. 2020. How China Detects and Blocks Shadowsocks. In Proceedings of the ACM Internet Measurement Conference (IMC ‘20). <a href="https://dl.acm.org/doi/10.1145/3419394.3423644">https://dl.acm.org/doi/10.1145/3419394.3423644</a></li> <li>Mingshi Wu, Jackson Sippe, Danesh Sivakumar, Jack Burg, Peter Anderson, Xiaokang Wang, Kevin Bock, Amir Houmansadr, Dave Levin, and Eric Wustrow. How the Great Firewall of China Detects and Blocks Fully Encrypted Traffic. In 32nd USENIX Security Symposium (USENIX Security 23). <a href="https://www.usenix.org/conference/usenixsecurity23/presentation/wu-mingshi">https://www.usenix.org/conference/usenixsecurity23/presentation/wu-mingshi</a></li> <li>Zhiniang Peng. 2019. Redirect attack on Shadowsocks stream ciphers. <a href="https://github.com/edwardzpeng/shadowsocks/blob/master/Redirect%20attack%20on%20Shadowsocks%20stream%20ciphers.pdf">https://github.com/edwardzpeng/shadowsocks/blob/master/Redirect%20attack%20on%20Shadowsocks%20stream%20ciphers.pdf</a></li> <li>shadowsocks. shadowsocks-libev. <a href="https://github.com/shadowsocks/shadowsocks-libev">https://github.com/shadowsocks/shadowsocks-libev</a></li> <li>shadowsocks docs. <a href="https://shadowsocks.org/">https://shadowsocks.org/</a></li> <li>Innokrea Team. Cryptography – stream ciphers. <a href="https://www.innokrea.com/cryptography-stream-ciphers/">https://www.innokrea.com/cryptography-stream-ciphers/</a></li> </ul>]]></content><author><name></name></author><category term="GFW"/><summary type="html"><![CDATA[Shadowsocks is the most influential censorship circumvention protocol up until today]]></summary></entry><entry><title type="html">GFW Technical Review 04 – The West Chamber Project</title><link href="https://kaiyanfan.github.io/blog/2026/gfw04/" rel="alternate" type="text/html" title="GFW Technical Review 04 – The West Chamber Project"/><published>2026-01-18T00:00:00+00:00</published><updated>2026-01-18T00:00:00+00:00</updated><id>https://kaiyanfan.github.io/blog/2026/gfw04</id><content type="html" xml:base="https://kaiyanfan.github.io/blog/2026/gfw04/"><![CDATA[<figure style="text-align:center;"> <img src="/assets/img/posts/gfw04/cover.png" width="70%"/> <figcaption>待月西厢下，迎风户半开。隔墙花影动，疑是玉人来。</figcaption> </figure> <p>Most circumvention technologies rely on some form of proxy and an encrypted channel between the user and the proxy, such as a VPN. However, there exists an entirely different class of circumvention technologies – much less well known today – that does not rely on any proxy at all. These techniques focus on the TCP protocol and GFW’s implementation of the TCP stack, achieving circumvention by exploiting inherent vulnerabilities in how GFW handles TCP streams.</p> <hr/> <h4 id="tcp-based-evasion">TCP-Based Evasion</h4> <p>One of the earliest proposals was to simply ignore the TCP RST packets generated by GFW, as RST injection was the only mechanism used by GFW’s on-path DPI component to terminate connections. While this was demonstrated to work, it was never practical: even if users could tweak their local TCP stack to ignore resets, TCP RST packets are sent to both ends of the connection, and the remote server would close the connection regardless.</p> <p>TCP is a stateful protocol. Both endpoints maintain a set of states – connection state, sequence number, transmission window, and so on – collectively known as the TCB (Transmission Control Block). Crucially, for GFW to perform TCP stream reassembly, it must track the state of every connection traversing its network. If GFW becomes desynchronized – that is, if it loses accurate track of the TCB – it can no longer reliably reassemble the TCP flow. For example, with incorrect sequence numbers, it wouldn’t know how to reorder packets or whether to wait for retransmission.</p> <p>The key principle of TCP-based evasion is to desynchronize GFW while keeping the connection alive with the remote server. A common approach is to trick GFW into believing that a TCP connection has been closed when in fact it remains active. Since the total number of possible TCP connections is enormous (every combination of the 4-tuple: source IP, source port, destination IP, and destination port), GFW cannot maintain state for every possible connection. It can only feasibly track active connections and discard state for those it believes have closed. Therefore, if GFW thinks a connection is closed, it stops censoring that connection.</p> <p>From GFW’s perspective, defending against desynchronization is fundamentally difficult. TCP is a complex protocol with a large state space. Ambiguities inevitably arise in how packets or states are handled at the protocol’s edge cases, and different TCP implementations can exhibit different behaviors. For performance reasons, GFW’s TCP stack must be lightweight and therefore cannot be fully RFC-compliant. This is the attack vector: if we can identify how GFW’s TCP implementation differs from standard implementations, we may be able to exploit those differences. In fact, even if GFW managed to faithfully replicate the TCP implementation used by the endpoints, it would still be vulnerable to desynchronization. GFW lacks full visibility into the actual states maintained by both sides of the connection – it can only infer them. Furthermore, it has no knowledge of end-to-end network conditions, such as where packet drops occur.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw04/tcp_state.png" width="50%"/> <figcaption>The state transition in TCP protocol is complicated, leaving plenty of room for ambiguity</figcaption> </figure> <hr/> <h4 id="the-west-chamber-project">The West Chamber Project</h4> <p>The West Chamber Project was an early attempt at practical TCP-based evasion. It performs a TCP insertion attack against GFW from the client side by sending carefully crafted packets to trick GFW into believing the TCP connection has closed.</p> <p>The insertion happens during the TCP handshake, when the client receives a SYN/ACK from the remote server. Instead of responding with an ACK packet, the client first sends a FIN packet with an invalid sequence number.</p> <p>From GFW’s perspective, it sees a FIN packet and concludes that the connection has been terminated. GFW does not validate the sequence number because accurately tracking sequence numbers is computationally expensive. However, an RFC-compliant remote server first checks the sequence number, determines it is invalid, and simply ignores the packet. The client then proceeds with the normal handshake. Since GFW is now desynchronized, this TCP stream is no longer subject to censorship.</p> <p>But this only desynchronizes the client-to-server direction. We still need to desynchronize the server-to-client direction. This is accomplished cleverly by injecting an ACK packet with a correct sequence number but an invalid acknowledgment number. This injected packet doesn’t immediately trigger any reaction from GFW – it simply appears to be a valid ACK. However, RFC 793 requires that a server in the SYN-RECEIVED state must respond with an RST when it receives an ACK with an invalid acknowledgment number. Crucially, even though the server sends this RST, it does not close the connection. Instead, it remains in the SYN-RECEIVED state, waiting for a valid ACK.</p> <p>When GFW observes this RST packet from the server, it concludes that the connection has closed – unaware that the server remains in SYN-RECEIVED state. The client, meanwhile, drops this RST because it contains an invalid sequence number. At this point, GFW is fully desynchronized in both directions, while the remote server is still waiting in SYN-RECEIVED state. The client then completes the handshake with a valid ACK and can begin transferring data without GFW’s interference.</p> <p>This client-side component is named ZHANG, after Zhang Sheng, a character in the classical Chinese romance “The Story of the Western Chamber” (西厢记).</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw04/zhang.png" width="70%"/> <figcaption>The full packet flow of TCP handshake with ZHANG injecting two packets</figcaption> </figure> <h4 id="the-cui-component">The CUI Component</h4> <p>West Chamber includes a separate server-side plugin called CUI, named after Cui Yingying, the other protagonist in the same love story. CUI operates independently from ZHANG.</p> <p>CUI works by injecting two pairs of SYN/ACK and RST packets after receiving the initial SYN. The SYN/ACK contains an invalid acknowledgment number, and the RST contains an invalid sequence number. The client ignores all of these packets, but they thoroughly confuse GFW, rendering it unable to track the connection in either direction. Once again, this exploits GFW’s inability to accurately track sequence and acknowledgment numbers. After injecting these packets, the server sends the real SYN/ACK response and continues the connection undetected.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw04/cui.png" width="70%"/> <figcaption>Packet flow of TCP handshake with CUI injecting four packets from server side</figcaption> </figure> <h4 id="dns-component">DNS Component</h4> <p>West Chamber is not limited to TCP-based evasion; it also includes a DNS component that defends against GFW’s DNS poisoning.</p> <p>To use this feature, users must first configure their DNS resolver to point to an overseas DNS server, since domestic servers contain poisoned records. As explained in Blog 01, GFW injects fake DNS responses that race ahead of legitimate responses from the actual DNS server. These fake responses have certain fingerprints that West Chamber exploits. In particular, the spoofed IP addresses that GFW generated came from a very limited set. West Chamber performs packet filtering based on these known fake IPs, allowing the client to discard GFW’s spoofed responses and use the legitimate ones.</p> <h4 id="variants">Variants</h4> <p>The West Chamber Project’s implementation represents just one of many ways to perform TCP insertion attacks. Beyond manipulating sequence and acknowledgment numbers, other techniques include:</p> <ul> <li>TCP checksum manipulation: Crafting packets with invalid checksums that GFW may process differently than the endpoints</li> <li>Packet reordering: Intentionally sending packets out of order to confuse GFW’s reassembly logic</li> <li>TTL manipulation: Setting the TTL value so that packets reach GFW but expire before reaching the remote server</li> </ul> <p>Any discrepancy between GFW’s handling of TCP and the real server’s handling represents a potential attack vector.</p> <hr/> <h4 id="resynchronization">Resynchronization</h4> <p>West Chamber was more of a research project than one with large-scale real-world impact. While clever and well-crafted, GFW evolved quickly in response.</p> <p>GFW combats these attacks by introducing a resynchronization mechanism: instead of abandoning state tracking after being desynchronized, it attempts to resynchronize its TCB under certain conditions. According to researchers’ measurements, scenarios such as multiple SYN packets, multiple SYN-ACK packets, ACKs with manipulated acknowledgment numbers, or unexpected RST packets could all trigger resynchronization, bringing GFW back to actively censoring the connection and breaking West Chamber’s fundamental assumption. Such mechanisms always incur additional computational costs, so they tend to be simple, cost-effective, and require minimal state tracking.</p> <h4 id="countering-resynchronization">Countering Resynchronization</h4> <p>New strategies emerged to combat GFW’s resynchronization mechanism. The key idea is to gain sufficient understanding of how resynchronization works. Then, instead of merely desynchronizing GFW (which would trigger resynchronization), we can inject a packet that forces GFW into its resynchronization state, followed by another packet with an invalid sequence number that causes GFW to resynchronize into an incorrect state.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw04/resync.png" width="70%"/> <figcaption>A more sophisticated insertion attack targeting GFW's re-synchronization mechanism, proposed by Zhongjie Wang et al</figcaption> </figure> <hr/> <h4 id="systematic-discovery-of-insertion-packets">Systematic Discovery of Insertion Packets</h4> <p>Another area of study is the systematic generation of insertion packets. Any TCP insertion attack that manipulates GFW’s TCB must ensure that the insertion packets:</p> <ol> <li>Are not dropped by network middleboxes between the client and GFW</li> <li>Do not alter the remote server’s TCB in ways that cause it to close the connection</li> </ol> <p>This is a challenging problem along multiple dimensions. First, we do not have access to GFW’s TCP implementation specifications or source code – its behavior can only be studied through measurement. Second, both TCP implementations and network conditions are highly diverse. Any proposed solution must be compatible with the majority of real-world configurations while remaining effective against GFW. To address this, researchers have developed automated tools to systematically discover such discrepancies and generate effective insertion packets.</p> <hr/> <h4 id="closing-thoughts">Closing Thoughts</h4> <p>TCP insertion attacks have the potential to circumvent GFW without requiring additional proxies – a significant advantage over other circumvention solutions. However, this approach has never achieved mainstream adoption. Ultimately, successful TCP insertion methods require deep understanding of GFW’s TCP stack, which itself evolves constantly. The technique has never been reliable enough for practical use due to its reliance on edge cases in the TCP protocol and uncertainty about endpoint implementations and network paths. Nevertheless, it has revealed a great deal about GFW’s inner workings and remains primarily of academic interest rather than seeing large-scale deployment.</p> <p>The mainstream eventually converged on proxy-based solutions. The single most influential one, Shadowsocks, emerged in 2012 – two years after the West Chamber Project. That will be the subject of the next blog.</p> <hr/> <h4 id="references">References</h4> <ul> <li>Zhongjie Wang, Yue Cao, Zhiyun Qian, Chengyu Song, and Srikanth V. Krishnamurthy. Your state is not mine: a closer look at evading stateful internet censorship. In Proceedings of the 2017 Internet Measurement Conference (IMC ‘17). <a href="https://doi.org/10.1145/3131365.3131374">https://doi.org/10.1145/3131365.3131374</a></li> <li>SymTCP: Eluding Stateful Deep Packet Inspection with Automated Discrepancy Discovery. Zhongjie Wang, Shitong Zhu, Yue Cao, Zhiyun Qian, Chengyu Song, Srikanth Krishnamurthy, Tracy D. Braun, Kevin S. Chan. In Network and Distributed Systems Security (NDSS) Symposium 2020. <a href="https://dx.doi.org/10.14722/ndss.2020.24083">https://dx.doi.org/10.14722/ndss.2020.24083</a></li> <li>Sheharbano Khattak, Mobin Javed, Philip D. Anderson, Vern Paxson. Towards Illuminating a Censorship Monitor’s Model to Facilitate Evasion. 3rd USENIX Workshop on Free and Open Communications on the Internet (FOCI 13). <a href="https://www.usenix.org/conference/foci13/workshop-program/presentation/khattak">https://www.usenix.org/conference/foci13/workshop-program/presentation/khattak</a></li> <li>Richard Clayton, Steven J. Murdoch, and Robert N. M. Watson. 2006. Ignoring the Great Firewall of China. <a href="https://www.cl.cam.ac.uk/~rnc1/ignoring.pdf">https://www.cl.cam.ac.uk/~rnc1/ignoring.pdf</a></li> <li>T. Ptacek, T.N. Newsham. 1998. Insertion, Evasion, and Denial of Service: Eluding Network Intrusion Detection. <a href="https://www.cs.unc.edu/~fabian/course_papers/PtacekNewsham98.pdf">https://www.cs.unc.edu/~fabian/course_papers/PtacekNewsham98.pdf</a></li> <li>Jon Postel. 1981. Transmission Control Protocol. RFC 793. <a href="https://tools.ietf.org/html/rfc793">https://tools.ietf.org/html/rfc793</a></li> <li>scholarzhang. 2010. West Chamber Project. <a href="https://github.com/codegooglecom/scholarzhang">https://github.com/codegooglecom/scholarzhang</a></li> </ul>]]></content><author><name></name></author><category term="GFW"/><summary type="html"><![CDATA[TCP Based Evasion, TCP Insertion Attack, and the West Chamber Project]]></summary></entry><entry><title type="html">GFW Technical Review 03 – Deep Packet Inspection</title><link href="https://kaiyanfan.github.io/blog/2026/gfw03/" rel="alternate" type="text/html" title="GFW Technical Review 03 – Deep Packet Inspection"/><published>2026-01-11T00:00:00+00:00</published><updated>2026-01-11T00:00:00+00:00</updated><id>https://kaiyanfan.github.io/blog/2026/gfw03</id><content type="html" xml:base="https://kaiyanfan.github.io/blog/2026/gfw03/"><![CDATA[<figure style="text-align:center;"> <img src="/assets/img/posts/gfw03/cover.png" width="70%"/> </figure> <p>The GFW is far more than a traditional firewall. Architecturally, it resembles a large-scale Intrusion Detection and Prevention System (IDPS), similar to those deployed in enterprise networks, government agencies, or financial institutions. Conceptually, it operates much like the security systems banks use to protect internal assets: it observes traffic, analyzes behavior, and identifies policy violations.</p> <p>The challenges, methodologies, and design trade-offs of IDPS systems apply directly to the GFW. And at the heart of any IDPS lies the ability to understand traffic behavior and intent. This requires <strong>Deep Packet Inspection (DPI)</strong> – the examination of every connection and packet to determine whether the communication should be allowed or blocked.</p> <p>What distinguishes the GFW is not its underlying concept, but its scale. The throughput and geographical coverage it must support dwarf any enterprise IDPS deployment, rendering most commercial architectures insufficient. To meet this challenge, the GFW relies on a design that emphasizes distribution, parallelism, and extremely high performance.</p> <hr/> <h4 id="load-distribution">Load Distribution</h4> <p>To manage the enormous traffic volume on national backbone links, the GFW employs a distributed, on-path architecture supported by data-center–scale compute resources. Its design is highly scalable and elastic.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw03/topology.png" width="80%"/> </figure> <p>As described in the first blog post, the GFW primarily uses passive network taps to obtain a copy of traffic on backbone links. Multiple tapped streams are aggregated and load-balanced into a set of parallel data pipelines. This load balancing is likely performed based on the flow 5-tuple: source IP, source port, destination IP, destination port, and transport protocol.</p> <p>Each data stream is then processed by a cluster of DPI sensors (or IDS sensors). Each “sensor” implements a different traffic analysis algorithm. Sensors analyzing the same stream may also share intermediate information or cooperate to refine a detection result. The output of these sensors – whether scores, classification labels, or rule violations—is then forwarded to downstream systems responsible for logging, alert generation, or active response measures such as packet injection.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw03/dpi.png" width="80%"/> <figcaption>Logical Topology of GFW’s DPI system, consisting of a load balancer, a cluster of DPI sensors, and downstream services</figcaption> </figure> <hr/> <h4 id="packet-processing">Packet Processing</h4> <p>In a conventional system, packets arriving at a host must traverse the kernel’s networking stack and are copied multiple times: from NIC buffers to kernel memory and then into user space. This overhead becomes prohibitive at backbone throughput. To avoid this cost, the GFW implements zero-copy packet ingestion by modifying NIC drivers. Packets are DMA’d directly into user-space memory buffers shared with DPI processes, bypassing the kernel entirely.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw03/dma.png" width="70%"/> <figcaption>The zero-copy stack used in early versions of GFW</figcaption> </figure> <p>Because many protocols cannot be accurately identified from a single packet, DPI engines must perform TCP stream reassembly. To support this, the GFW implements a lightweight TCP/IP stack in user space, capable of reconstructing flows and tracking per-connection state. Numerous optimizations are necessary to enable this stack to handle millions of concurrent flows and sustain high throughput.</p> <p>However, this design introduces new attack surfaces. As we will explore in the next blog, a user-space self-implemented TCP stack can have subtle inconsistencies. Carefully crafted packet sequences can cause parsing errors or desynchronization between the DPI engine and the real network endpoints.</p> <p>Unlike a conventional TCP/IP stack, which must manage full bidirectional communication, the GFW’s reassembly logic only needs to parse inbound traffic from one direction. This simplification allows the system to run multiple parallel instances of its TCP stack, taking advantage of multi-core architectures. It is yet another example of the GFW’s philosophy of distribution and parallelism.</p> <hr/> <h4 id="dpi-methodologies">DPI methodologies</h4> <p>Early DPI techniques used by the GFW were relatively simple and focused mainly on two dimensions:</p> <h5 id="1-pattern-matching">1. Pattern Matching</h5> <p>Often implemented as string matching on keywords, URL substrings, hostnames, or protocol signatures. While conceptually straightforward, achieving high performance across massive traffic volumes requires highly optimized algorithms and fast, memory-efficient state machines.</p> <h5 id="2-protocol-identification">2. Protocol Identification</h5> <p>Even in its early iterations, the GFW supported detection of well-known application-layer protocols such as HTTP, SMTP, and FTP, as well as early circumvention protocols like traditional VPNs and tools such as Freegate. As discussed in the previous blog, these early circumvention methods offered little or no traffic obfuscation, making them trivial to identify using protocol heuristics or signature matching.</p> <h5 id="3-port-matching">3. Port Matching</h5> <p>The GFW also looks at the port number for protocol identification. For example, OpenVPN often uses UDP port 1994. Though this can be easily bypassed by circumvention tools as port numbers are just conventions.</p> <hr/> <h4 id="residual-censorship">Residual Censorship</h4> <p>Residual censorship is a relatively recent technique adopted by the GFW. It acts as a punitive mechanism: once the GFW detects and blocks a connection it considers suspicious, it continues to block subsequent attempts between the same endpoints for a short period of time – even if those later attempts are completely benign. In effect, the endpoints become temporarily blacklisted.</p> <p>Empirical observations suggest that the GFW keys this temporary blacklist using a 3-tuple: (client IP, server IP, server port). This choice reflects a practical compromise. By applying a coarse-grained but short-lived blacklist, the GFW can significantly increase blocking effectiveness while limiting the collateral damage caused by potential misclassification. The result is an enforcement mechanism that is aggressive in the moment yet self-corrects quickly enough to avoid long-term disruption to normal traffic.</p> <hr/> <h4 id="closing-thoughts">Closing Thoughts</h4> <p>Deep Packet Inspection forms the core analytical capability of the GFW. As both the GFW and circumvention technologies evolve, detection methodologies have grown increasingly sophisticated. That said, the system’s architectural emphasis on performance – particularly its reliance on parallel DPI pipelines and user-space TCP stream reassembly – introduces significant structural weaknesses.</p> <p>In the next blog, we will examine how these weaknesses arise and how certain circumvention protocols exploit inconsistencies in the GFW’s TCP reassembly logic.</p> <hr/> <h4 id="references">References</h4> <ul> <li>Sheharbano Khattak, Mobin Javed, Philip D. Anderson, Vern Paxson. Towards Illuminating a Censorship Monitor’s Model to Facilitate Evasion. 3rd USENIX Workshop on Free and Open Communications on the Internet (FOCI 13). <a href="https://www.usenix.org/conference/foci13/workshop-program/presentation/khattak">https://www.usenix.org/conference/foci13/workshop-program/presentation/khattak</a></li> <li>B. Mukherjee, L. T. Heberlein and K. N. Levitt. 1994. Network intrusion detection. IEEE Network. <a href="https://ieeexplore.ieee.org/abstract/document/283931">https://ieeexplore.ieee.org/abstract/document/283931</a></li> <li>深入理解GFW: 内部结构. <a href="http://gfwrev.blogspot.com/2010/02/gfw.html">http://gfwrev.blogspot.com/2010/02/gfw.html</a></li> <li>陈训逊, 方滨兴, 李蕾. 高速网络环境下入侵检测系统结构研究. 计算机研究与发展. <a href="https://www.icir.org/christian/outback/fang.pdf">https://www.icir.org/christian/outback/fang.pdf</a></li> <li>张兆心, 方滨兴, 胡铭曾. 支持IDS的高速网络信息获取体系结构. 北京邮电大学学报. <a href="https://journal.bupt.edu.cn/EN/article/downloadArticleFile.do?attachType=PDF&amp;id=1712">https://journal.bupt.edu.cn/EN/article/downloadArticleFile.do?attachType=PDF&amp;id=1712</a></li> </ul>]]></content><author><name></name></author><category term="GFW"/><summary type="html"><![CDATA[Deep Packet Inspection is GFW's most powerful tool]]></summary></entry><entry><title type="html">GFW Technical Review 02 – VPN</title><link href="https://kaiyanfan.github.io/blog/2026/gfw02/" rel="alternate" type="text/html" title="GFW Technical Review 02 – VPN"/><published>2026-01-04T00:00:00+00:00</published><updated>2026-01-04T00:00:00+00:00</updated><id>https://kaiyanfan.github.io/blog/2026/gfw02</id><content type="html" xml:base="https://kaiyanfan.github.io/blog/2026/gfw02/"><![CDATA[<figure style="text-align:center;"> <img src="/assets/img/posts/gfw02/cover.png" width="70%"/> </figure> <p>When the Great Firewall first deployed its earliest filtering mechanisms – IP blocking, DNS poisoning, and basic keyword-based DPI – the Internet was still dominated by plaintext protocols. This gave the system broad visibility into traffic contents, but it also meant it was highly vulnerable to any technology that encrypted or encapsulated traffic. VPNs quickly emerged as a natural response. Not because they were designed for circumvention, but because they offered a mature, standardized way to wrap traffic inside an encrypted tunnel, making the underlying communication opaque to simple filtering logic. If the traffic never revealed its true destination, IP- or DNS-based blocking became ineffective. And once the payload was encrypted, keyword-based DPI could no longer read or classify it. The assumption at the time – largely correct – was that encrypted tunnels would appear “opaque enough” that early DPI systems could not meaningfully identify them.</p> <hr/> <h4 id="how-vpns-work">How VPNs Work</h4> <p>At its core, a VPN is a mechanism that takes arbitrary IP packets and encapsulates them inside another protocol, typically with encryption applied to the inner payload. A VPN client creates a virtual tunnel interface, which behaves like a normal network adapter. Applications send packets to this interface as if they were sending them directly to the Internet. Instead of being routed normally, these packets are wrapped inside an outer VPN transport protocol and then encrypted. Conceptually, a VPN packet looks like this:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Outer IP header → Transport header (TCP/UDP) → Encrypted VPN payload (inner IP packet)
</code></pre></div></div> <p>The outer IP header points to the VPN server, usually located outside the censored network. The server decrypts the packets, restores the original IP packets, and forwards them to their intended destinations. As a result, the only traffic visible to the GFW is the encrypted, encapsulated VPN tunnel. The destination IPs, DNS queries, and application-layer content are hidden.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw02/openvpn.png" width="70%"/> </figure> <p>However, not everything is concealed: <strong>the outer IP and transport headers remain plaintext</strong>. If GFW operators know the IP address of a VPN endpoint, they can still block it outright.</p> <hr/> <h4 id="common-vpn-protocols">Common VPN Protocols</h4> <p>Different VPN protocols encapsulate traffic in different ways, which also influences how detectable they are.</p> <h5 id="ipsec">IPsec</h5> <p>One of the earliest standardized VPN protocols. It uses ESP (Encapsulating Security Payload) and AH (Authentication Header) and relies on IKE (Internet Key Exchange) for key negotiation. IPsec has recognizable packet formats and commonly uses UDP ports 500 and 4500, making it relatively easy to fingerprint.</p> <h5 id="openvpn">OpenVPN</h5> <p>A later protocol that reuses TLS for its handshake and cryptographic layer. OpenVPN can run over UDP or TCP, often defaulting to UDP/1194. Because it borrows from TLS but does not fully mimic HTTPS, its traffic patterns are distinctive.</p> <h5 id="l2tppptp">L2TP/PPTP</h5> <p>Older tunneling technologies widely supported in early consumer devices. PPTP relied on GRE and MS-CHAP, and L2TP often ran in combination with IPsec. Over time they fell out of favor due to both security and performance limitations.</p> <h5 id="ssh-tunneling">SSH Tunneling</h5> <p>Not technically a VPN protocol but functionally similar. Users run SSH clients and servers on each end, encapsulating traffic inside an encrypted SSH stream. While simpler, SSH sessions also have identifiable handshake patterns.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw02/ssh.png" width="70%"/> <figcaption>SSH tunnelling works in a very similar fashion to VPN</figcaption> </figure> <hr/> <h4 id="case-study-openvpn">Case Study: OpenVPN</h4> <p>OpenVPN is a representative example of a classic VPN protocol and shows how early VPN traffic appeared “on the wire.”</p> <p>OpenVPN connections are stateful. To begin, the client sends a “Client Reset” packet, and the server responds with a “Server Reset.” This exchange establishes a session ID and sets up a control channel. Afterward, the client and server perform a TLS handshake over this control channel, leveraging OpenSSL for cryptography. Once the TLS session is established and keys are exchanged, the data channel becomes active and encrypted payloads can flow.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw02/openvpn_hsk.png" width="70%"/> <figcaption>OpenVPN Session Establishment</figcaption> </figure> <p>Although OpenVPN encrypts the data channel, it was never designed to hide the fact that it is a VPN. Several aspects remain visible:</p> <ul> <li>The control channel is not further obfuscated beyond standard TLS.</li> <li>The data channel exposes certain fields, such as opcode and Key ID, in plaintext.</li> <li>Opcodes appear at fixed offsets in packets and follow predictable sequences.</li> </ul> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw02/openvpn_hsk.png" width="70%"/> <figcaption>OpenVPN wireline packet format. It exposes opcode in plaintext</figcaption> </figure> <p>For an adversary like the GFW, these characteristics create reliable identification vectors. A censor can observe packet sequences, opcode patterns, and handshake structures and classify them with high accuracy. As DPI matured, OpenVPN’s distinct “fingerprint” became trivial to detect and block.</p> <hr/> <h4 id="closing-thoughts">Closing Thoughts</h4> <p>In the early era of censorship circumvention, VPNs stood out as an immediately available and technically mature option. Their impact was so strong that, even today, many users refer to all circumvention tools generically as “VPNs,” regardless of what protocol they actually employ.</p> <p>However, VPNs were not purpose-built for censorship resistance. They encrypted traffic, but they did not hide metadata or protocol identity. As the GFW adopted more advanced Deep Packet Inspection techniques, these weaknesses became clear. Traditional VPNs increasingly struggled to evade detection, and new families of circumvention protocols emerged in response. We will explore these DPI mechanisms – and how they shaped the next generation of circumvention tools – in the next post.</p> <hr/> <h4 id="references">References</h4> <ul> <li>Great Firewall father speaks out. <a href="http://www.china.org.cn/china/2011-02/18/content_21951602.htm">http://www.china.org.cn/china/2011-02/18/content_21951602.htm</a></li> <li>OpenVPN Protocol. <a href="https://openvpn.net/community-resources/openvpn-protocol/">https://openvpn.net/community-resources/openvpn-protocol/</a></li> <li>SSH Tunneling. <a href="https://www.ssh.com/academy/ssh/tunneling">https://www.ssh.com/academy/ssh/tunneling</a></li> <li>What is OpenVPN Protocol. <a href="https://www.vpnunlimited.com/help/vpn-protocols/open-vpn-protocol">https://www.vpnunlimited.com/help/vpn-protocols/open-vpn-protocol</a></li> <li>Diwen Xue, Reethika Ramesh, Arham Jain, Michalis Kallitsis, J. Alex Halderman, Jedidiah R. Crandall, Roya Ensafi. OpenVPN is Open to VPN Fingerprinting. 31st USENIX Security Symposium (USENIX Security 22). <a href="https://www.usenix.org/conference/usenixsecurity22/presentation/xue-diwen">https://www.usenix.org/conference/usenixsecurity22/presentation/xue-diwen</a></li> </ul>]]></content><author><name></name></author><category term="GFW"/><summary type="html"><![CDATA[How does VPN work to circumvent GFW]]></summary></entry><entry><title type="html">GFW Technical Review 01 – Architecture</title><link href="https://kaiyanfan.github.io/blog/2026/gfw01/" rel="alternate" type="text/html" title="GFW Technical Review 01 – Architecture"/><published>2026-01-01T00:00:00+00:00</published><updated>2026-01-01T00:00:00+00:00</updated><id>https://kaiyanfan.github.io/blog/2026/gfw01</id><content type="html" xml:base="https://kaiyanfan.github.io/blog/2026/gfw01/"><![CDATA[<figure style="text-align:center;"> <img src="/assets/img/posts/gfw01/cover.png" width="70%"/> </figure> <p>In the late 1990s and early 2000s, China’s Internet infrastructure expanded rapidly. As connectivity grew, policymakers sought mechanisms to manage cross-border information flows in line with evolving legal and regulatory requirements. The physical layout of the early Chinese Internet made this goal technically achievable: most international traffic passed through a handful of centralized exchange points. These “choke points” provided natural locations for introducing filtering technologies without redesigning the entire domestic network.</p> <p>The earliest versions of the Great Firewall (GFW) were built around these critical international gateways. At these points, border routers could be configured with access-control rules, external filtering appliances could copy and inspect traffic, packets could be injected to interrupt connections, and centralized controllers could coordinate policies across carriers. Backbone operators – large state-affiliated telecommunications companies – maintained this infrastructure in coordination with newly established regulatory entities responsible for information control.</p> <p>Even at this early stage, GFW was never a single firewall appliance. It would be technically impossible to enforce broad, heterogeneous policies across all cross-border traffic using a single device or application. From the beginning, the GFW was a large-scale distributed system: a collection of loosely coupled components that cooperated to achieve nationwide filtering goals. Among these components, three mechanisms eventually emerged as foundational pillars of its architecture.</p> <hr/> <h4 id="ip-address-blocking">IP Address Blocking</h4> <p>Routers at backbone or gateway points can maintain ACLs and simply drop packets to and from specific IP ranges. This method is reliable – routers almost never misapply an ACL – and computationally cheap. However, the operational burden shifts to the operator, who must maintain a constantly updated list of target IP addresses. This is challenging because the number of websites is enormous, and IP addresses frequently change. IP-based blocking also tends to over-block, particularly for shared hosting providers or CDNs where many domains share the same address.</p> <p>Even though ACL-based blocking is computationally inexpensive, maintaining extremely large ACLs on a small number of backbone routers becomes impractical. To address this, the GFW uses <strong>null routing</strong>, which distributes the blocking burden across the entire domestic network. Understanding null routing requires a quick look at how routers communicate. Routers share routing information through BGP, a protocol that lets routing announcements propagate automatically across the network. Critically, this system is based on trust: routers assume the information they receive from peers is correct.</p> <p>This trust relationship gives the GFW an opportunity. By injecting a false BGP announcement for an IP address it wants to block – advertising a route that leads nowhere – the GFW causes the entire network to route packets for that destination into a “black hole.” In other words, incorrect routing information propagates through the network until every router collectively drops traffic to the targeted IP address. This systemwide null route is both efficient and very difficult for typical users to work around.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw01/null_routing.png" width="70%"/> <figcaption>The network topology for spreading null routings to the network, presented by the architects of GFW</figcaption> </figure> <hr/> <h4 id="port-blocking">Port Blocking</h4> <p>In addition to filtering based on destination IP addresses, backbone routers can also block traffic targeting specific destination ports. On Cisco equipment, this capability is typically implemented through ACL-Based Forwarding (ABF). Port-level blocking gives operators more granular control, since many IP addresses host multiple services. Blocking an entire IP could unintentionally disrupt unrelated applications, whereas selectively filtering ports allows censorship systems to impair only the targeted service while leaving others reachable.</p> <hr/> <h4 id="dns-poisoning">DNS Poisoning</h4> <p>IP blocking is operationally expensive and often unreliable because IP addresses change frequently. Domain names, however, tend to remain stable. DNS interference therefore became a more desirable and scalable technique.</p> <p>The GFW can poison domestic DNS resolvers by providing forged responses. Because DNS has a hierarchical, cache-driven design, an incorrect resolution at the root or ISP level quickly propagates through caches and eventually contaminates the entire domestic DNS ecosystem.</p> <p>In principle, users could bypass poisoned resolvers by querying foreign DNS servers. To counter this, the GFW injects forged DNS responses when it detects outbound DNS queries crossing the border. These forged responses are almost always faster than the legitimate ones—because they are injected locally rather than traveling to Japan, the U.S., or elsewhere, so DNS clients accept the forged record and ignore the genuine response that arrives later.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw01/dns.png" width="70%"/> <figcaption>The forged DNS responses also contribute to DNS poisoning. As they travel to the client, they update the DNS cache at various levels along the route</figcaption> </figure> <hr/> <h4 id="keyword-based-filtering-early-dpi">Keyword-Based Filtering (Early DPI)</h4> <p>In the early days of the Internet, most traffic was plaintext. This allowed the GFW to implement straightforward pattern matching within TCP streams. To do this, operators tapped the cross-border choke points and captured a copy of all international traffic off-path. The traffic was sharded and distributed to a large server farm performing early forms of Deep Packet Inspection (DPI).</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw01/topology.png" width="70%"/> <figcaption>GFW taps the cross-border traffics and injects disruptive packets</figcaption> </figure> <p>These DPI systems could scan unencrypted HTTP requests and match specific keywords. They could also perform limited stateful inspection, tracking the progress of a TCP stream and identifying behavioral patterns, though this was more computationally expensive. In practice, early DPI deployments were mostly stateless.</p> <p>When a DPI device decided a connection violated policy, it injected forged TCP RST packets to both endpoints, abruptly and falsely terminating the connection. This behavior became one of the earliest and most recognizable signatures of the GFW in action.</p> <figure style="text-align:center;"> <img src="/assets/img/posts/gfw01/rst.png" width="70%"/> <figcaption>GFW cuts off TCP connection by sending TCP RST packets to both ends of the communication</figcaption> </figure> <hr/> <h4 id="a-distributed-multi-layer-design">A Distributed, Multi-Layer Design</h4> <p>A core design philosophy of the GFW is that it should be distributed and multi-layered rather than monolithic. This principle is visible in both null routing and DNS poisoning: instead of concentrating all filtering at the border, responsibility is pushed outward into the network. Over time, this logic extended to DPI as well. Rather than perform all heavy inspection at international gateways – which would create massive bottlenecks – ISPs gradually took on more of this responsibility within the domestic backbone. This support for regional enforcement also enabled more flexible or region-specific policies, such as those observed in Xinjiang in recent years.</p> <p>This distributed approach provides scalability, fault-tolerance, and policy flexibility – properties that would be impossible with a centralized firewall.</p> <hr/> <h4 id="operational-challenges">Operational Challenges</h4> <p>Despite the conceptual simplicity of each mechanism, GFW faces significant operational challenges. The most persistent issue is how to minimize false positives. Conceptually, the GFW performs a binary classification task: determine whether a given connection violates policy. No classifier is perfect. IP lists become outdated, DPI may match the wrong substring, and legitimate flows can resemble disallowed ones.</p> <p>Like many classifiers, the GFW must balance precision and recall. Historically, it has been tuned toward high precision, prioritizing low false-positive rates even if that allows more false negatives. This balance, however, is adjustable. Operators can and do modify sensitivity, and during politically sensitive periods, the system has often behaved more aggressively.</p> <p>Leakage is another significant challenge. Any “false information” introduced by the GFW -such as poisoned DNS records or null routes – must stay strictly within national borders. Otherwise, it risks spreading through the global routing or DNS ecosystem and causing collateral damage. A well-known example occurred in 2010, when a Chilean DNS operator observed incorrect resolutions for domains like Facebook, YouTube, and Twitter. The issue was traced back to DNS queries inadvertently routed through China; the GFW injected forged responses, which then leaked outside the border due to insufficient direction-checking at the time.</p> <hr/> <h4 id="observable-characteristics">Observable Characteristics</h4> <p>Because the GFW’s architecture is not publicly documented, much of what is known comes from researchers and users examining externally visible behavior. Common observations include:</p> <ul> <li><strong>TCP RST injections</strong>: forged packets abruptly terminating connections.</li> <li><strong>Silent timeouts</strong>: connections stall indefinitely, often a signature of IP- or route-based blocking.</li> <li><strong>Forged DNS records</strong>: detectable when users manually compare DNS results or modify resolver settings.</li> <li><strong>Asymmetric behavior</strong>: outbound and inbound traffic may be treated differently, a pattern observed in various academic measurements.</li> </ul> <p>These behaviors collectively hint at a complex, distributed filtering system rather than a single filtering device.</p> <hr/> <h4 id="closing-thoughts">Closing Thoughts</h4> <p>The GFW began as a collection of simple, distributed mechanisms built around natural network choke points. Over time, these mechanisms have been refined, scaled, and partially decentralized, forming the basis of one of the most sophisticated national-level filtering architectures in the world. In the next post, we will shift perspective to the client side, examining how early VPN protocols appeared “on the wire” and how their design sparked a long and evolving interplay between censorship systems and circumvention technologies.</p> <hr/> <h4 id="references">References</h4> <ul> <li>The Great Firewall of China. <a href="https://www.wired.com/1997/06/china-3/">https://www.wired.com/1997/06/china-3/</a></li> <li>Cisco Leak: ‘Great Firewall’ of China Was a Chance to Sell More Routers. <a href="https://www.wired.com/2008/05/leaked-cisco-do/">https://www.wired.com/2008/05/leaked-cisco-do/</a></li> <li>Liu, G., Yun, X., Fang, B., Hu, M. 一种基于路由扩散的大规模网络控管方法. Journal of China Institute of Communications. <a href="https://www.docin.com/p-1321809121.html">https://www.docin.com/p-1321809121.html</a></li> <li>Global Internet Freedom Consortium. China Greate Firewall Revealed. <a href="http://www.internetfreedom.org/files/WhitePaper/ChinaGreatFirewallRevealed.pdf">http://www.internetfreedom.org/files/WhitePaper/ChinaGreatFirewallRevealed.pdf</a></li> <li>Deconstructing Great Firewall China. <a href="https://www.thousandeyes.com/blog/deconstructing-great-firewall-china">https://www.thousandeyes.com/blog/deconstructing-great-firewall-china</a></li> <li>Daniel Anderson. Splinternet Behind the Great Firewall of China. ACM Queue. <a href="https://queue.acm.org/detail.cfm?id=2405036">https://queue.acm.org/detail.cfm?id=2405036</a></li> <li>Anomalous behavior of the DNS on March 24th, 2010. <a href="https://www.nic.cl/anuncios/20100329-rootI-eng.html">https://www.nic.cl/anuncios/20100329-rootI-eng.html</a></li> <li>Anonymous. Towards a Comprehensive Picture of the Great Firewall’s DNS Censorship. 4th USENIX Workshop on Free and Open Communications on the Internet. <a href="https://www.usenix.org/system/files/conference/foci14/foci14-anonymous.pdf">https://www.usenix.org/system/files/conference/foci14/foci14-anonymous.pdf</a></li> <li>Richard Clayton, Steven J. Murdoch, and Robert N. M. Watson. Ignoring the Great Firewall of China. <a href="https://www.cl.cam.ac.uk/~rnc1/ignoring.pdf">https://www.cl.cam.ac.uk/~rnc1/ignoring.pdf</a></li> <li>Jedidiah R. Crandall, Daniel Zinn, Michael Byrd, Earl Barr, Rich East. ConceptDoppler: A weather tracker for internet censorship. Proceedings of the 2007 ACM Conference on Computer and Communications Security. <a href="https://www.cs.unm.edu/~crandall/concept_doppler_ccs07.pdf">https://www.cs.unm.edu/~crandall/concept_doppler_ccs07.pdf</a></li> <li>Sparks, Neo, Tank, Smith, Dozer. The Collateral Damage of Internet Censorship by DNS Injection. ACM SIGCOMM Computer Communication Review. <a href="https://conferences.sigcomm.org/sigcomm/2012/paper/ccr-paper266.pdf">https://conferences.sigcomm.org/sigcomm/2012/paper/ccr-paper266.pdf</a></li> <li>Xueyang Xu, Z. Morley Mao, and J. Alex Halderman. Internet censorship in china: where does the filtering occur? Proceedings of the 12th international conference on Passive and active measurement (PAM’11). <a href="https://dl.acm.org/doi/10.5555/1987510.1987524">https://dl.acm.org/doi/10.5555/1987510.1987524</a></li> <li>深入理解GFW: 内部结构. <a href="http://gfwrev.blogspot.com/2010/02/gfw.html">http://gfwrev.blogspot.com/2010/02/gfw.html</a></li> <li>深入理解GFW: DNS污染. <a href="http://gfwrev.blogspot.com/2009/11/gfwdns.html">http://gfwrev.blogspot.com/2009/11/gfwdns.html</a></li> </ul>]]></content><author><name></name></author><category term="GFW"/><summary type="html"><![CDATA[The early history and architecture of GFW]]></summary></entry></feed>